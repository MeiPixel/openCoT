# 第3节：进程管理

## 进程的概念和基本操作

进程是指正在运行的程序的实例，在操作系统中起着至关重要的作用。本节将介绍进程的基本概念，包括进程的定义、进程状态，进程的创建、终止和查看等基本操作。同时，提供实例演示如何通过命令行工具进行进程管理。

### 进程的定义

进程是计算机中正在运行的程序的实例。一个程序可以有多个进程实例，每个进程都有自己的内存空间、指令指针、堆栈等。进程是操作系统资源管理的基本单位，可以分配和回收系统资源，是操作系统执行各种任务的基本单位。

### 进程状态

进程状态是指进程从开始到结束的整个生命周期中所处的状态。在Linux系统中，进程状态可以分为以下几种：

- 运行状态（Running）：指进程正在执行或等待系统资源时处于可中断状态。

- 中断睡眠状态（Interruptible Sleep）：指进程等待一些事件的发生，一旦事件发生，就会被唤醒。

- 无中断睡眠状态（Uninterruptible Sleep）：指进程等待一些资源的释放，只有当资源可用时才能唤醒。

- 停止状态（Stopped）：指进程被一个信号停止执行。

- 僵尸状态（Zombie）：指进程已经退出，但是其父进程还没有调用wait()或waitpid()函数来回收其资源。

### 进程的创建和终止

在Linux系统中，可以使用fork()函数创建一个新的进程。fork()函数会将当前进程复制一份，并返回一个新的进程ID，父进程和子进程分别运行各自的代码。同时，Linux系统也提供了kill()函数来终止一个进程，kill命令可以通过发送信号来终止一个进程。

### 进程的查看

在Linux系统中，可以使用ps命令查看当前系统运行的进程。可以使用以下命令来列出所有进程：

```shell
ps aux
```

其中，a表示列出所有进程（包括其他用户），u表示详细信息输出，x表示包括无端口的进程。

同时，可以使用top命令实时监控系统运行的进程，显示各个进程的CPU使用率和内存使用情况等信息。

## 示例

### 创建和终止进程

首先，使用以下命令创建一个新的进程：

```shell
$ sudo fork
```

然后，使用以下命令查看所有进程：

```shell
$ ps aux
```

可以看到，当前系统中有两个进程：一个是bash进程，另一个是fork进程。

接下来，使用kill命令终止fork进程：

```shell
$ sudo kill [PID]
```

其中，[PID]表示要终止的进程ID。

### 查看进程信息

可以使用以下命令查看当前系统中所有进程的信息：

```shell
$ ps aux
```

也可以使用top命令实时监控系统运行的进程：

```shell
$ top
```

其中，top命令会按照CPU使用率和内存使用情况等指标排序，显示各个进程的详细信息。可以使用键盘上的方向键来上下滚动，按q键退出top命令。

### 实际应用

在实际应用中，进程创建、终止和查看等操作非常常见。比如，当我们启动一个服务时，系统会创建一个新的进程来处理请求；当我们卸载一个应用程序时，系统会终止该进程，并回收其资源。

在操作系统管理方面，对进程的掌握非常重要。只有掌握了进程的基本操作和状态，才能更好地管理系统资源，提高系统的性能。因此，熟练掌握进程管理技术，是每个Linux系统管理人员必须掌握的技能之一。

## 小结

本节介绍了进程的基本概念和操作，包括进程的定义、进程状态，进程的创建、终止和查看等基本操作。同时，提供了实例演示如何通过命令行工具进行进程管理，帮助读者深入了解操作系统的原理和机制。
# 第3节：进程管理

## 进程的信号和信号处理

进程信号是Linux进程间通信的一种方式，用于通知进程发生了某些特定的事件，例如Ctrl+C终止信号。Linux进程可通过发送和接收信号来与其他进程进行通信和协作。

常见的Linux进程信号包括：

- SIGKILL：强制杀死进程，无法忽略或捕获。
- SIGTERM：终止进程，允许进程进行清理操作。
- SIGINT：中断进程，通常由用户按下Ctrl+C产生。
- SIGSTOP：停止进程，无法忽略或捕获。

进程可以通过多种方式发送信号，例如使用kill命令或发送信号给进程组。同时，进程可定义信号处理函数，用于处理接收到的信号。

在Linux中，可以使用pidstat和kill命令演示进程信号的使用。示例命令如下：

```bash
# 向进程pid 1234发送SIGTERM信号
kill -TERM 1234

# 列出进程pid的信号使用情况
pidstat -s -p pid
```

## 示例和实践

下面提供一个实例，演示如何使用kill命令发送进程信号。假设我们有一个正在运行的名为myprocess的进程，进程PID为1234，需要将其终止。可以使用以下命令：

```bash
# 向进程pid 1234发送SIGTERM信号
kill -TERM 1234
```

该命令将向进程1234发送终止信号并等待进程清理操作完成。

## 注意事项和技巧

在使用进程信号时，需要特别注意以下事项：

- SIGKILL是一种强制终止进程的信号，应尽可能避免使用。
- 进程信号处理函数应尽可能短小精悍，以免影响进程性能。
- 在进程信号处理函数中应尽可能避免使用可能会导致死锁的操作。

## 检查和总结

结束该小节时，您应该能够：

- 理解Linux进程信号的概念和用法；
- 知道常见的Linux进程信号，以及如何发送和接收Linux进程信号；
- 能够演示如何使用kill命令发送进程信号。

## 参考和资源

- Linux进程管理 (https://www.linuxprobe.com/chapter-04.html)
- kill命令 (https://man7.org/linux/man-pages/man1/kill.1.html)
- pidstat命令 (https://man7.org/linux/man-pages/man1/pidstat.1.html)
## 第3节：进程管理

### 进程调度和优先级

在Linux中，进程是指正在运行的程序实例。进程的调度决定了哪个进程在什么时间运行，以及占用系统资源的优先级。

#### 进程调度算法

Linux操作系统采用多种进程调度算法，以满足不同应用场景的需求。常见的进程调度算法包括：

- **时间片轮转调度算法**：将CPU时间分为若干个时间片，每个进程按照先来先服务的原则占用一个时间片，用完后放回等待队列，等待下次调度。
- **优先级反转调度算法**：为了保证高优先级进程先被调度，低优先级进程在等待高优先级进程释放共享资源的时候，将优先级提升到高优先级进程的水平。
- **最短作业优先调度算法**：按照进程需要占用的CPU时间长短进行调度，确保长时间运行的进程不会无限占用CPU。
- **完全公平调度算法**：同时运行多个进程，每个进程被分配相同的CPU时间，以保证资源公平分配。

#### 进程调度类和优先级

几乎所有的Linux进程都属于以下五个调度类之一：

- **实时调度类**（SCHED_FIFO和SCHED_RR）：这些进程具有最高的优先级，不受时间片大小的限制。SCHED_FIFO调度类按先进先出（FIFO）的顺序运行，而SCHED_RR调度类允许进程共享CPU时间。
- **实时负载调度类**（SCHED_DEADLINE）：提供了更细粒度的调度控制和更优化的资源使用，用于追求极低延迟和更高的吞吐量的应用程序。
- **批量调度类**（SCHED_BATCH）：用于在后台运行的低优先级任务，不会影响实时任务的运行。
- **空闲调度类**（SCHED_IDLE）：只有在系统空闲时间才运行的进程。
- **普通调度类**（SCHED_OTHER）：这是默认的调度类，适用于大多数Linux进程。

Linux进程的优先级范围从-20到19，数字越小优先级越高。对于普通调度类的进程，优先级默认为0。可以使用命令`renice`来修改进程优先级。例如，将进程PID为1234的优先级调整为10可以使用以下命令：

```
renice 10 1234
```

#### 示例和实践

使用`top`命令可以查看运行进程的详细信息，包括进程名称、进程ID、优先级等。例如，下面是运行`top`命令得到的部分输出：

```
top - 13:07:48 up 21 days, 22:10,  1 user,  load average: 0.00, 0.01, 0.05
Tasks: 136 total,   1 running, 135 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.1 us,  0.1 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
MiB Mem :   7884.4 total,   3636.6 free,   2922.0 used,   1325.9 buff/cache
MiB Swap:      0.0 total,      0.0 free,      0.0 used.   4691.6 avail Mem 

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                                                  
 1276 root      20   0  357584  21308  12908 S   0.3   0.3   1:17.96 Xorg                                                                     
 2548 user1     20   0 3460736 343400  84592 S   0.3   4.2   0:44.48 gnome-shell                                                              
 1812 user1     20   0 2872748 119076  41240 S   0.0   1.5  19:38.46 firefox                                                                  
    1 root      20   0  168888   6792   4432 S   0.0   0.1   1:03.13 systemd                                                                  
    2 root      20   0       0      0      0 S   0.0   0.0   0:00.01 kthreadd                                                                 
    3 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_gp                                                                   
    4 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_par_gp                                                               
```

在这个输出中，PID为1276的Xorg进程具有最高的优先级（PR值为20），随后是其他进程。可以使用命令`nice`和`renice`来修改进程的优先级。

### 检查和总结

1. 什么是进程？
2. Linux中都采用了哪些进程调度算法？
3. 进程优先级的取值范围是多少？
4. 如何使用`top`命令查看系统进程的状态？
5. 如何使用`renice`命令修改进程的优先级？

### 参考和资源

- `man top`
- `man renice`
# 第3节：进程管理

## 进程间通信

进程间通信是指多个进程之间的数据交换和共享，通信的方式可以分为以下几种：

1. **管道**：由一个进程创建，然后另一个进程用于读取和写入。它只能用于具有父子关系的进程之间通信，并且只能在一个方向上传递数据。

2. **命名管道**：同样由一个进程创建，但是可以由多个进程读取和写入。它可以在不具有父子关系的进程之间传递数据，也可以在两个方向上传递数据。

3. **共享内存**：多个进程可以访问相同的内存区域，允许它们共享数据，这比传递大量数据的速度更快。

4. **消息队列**：进程可以将消息放入队列中，其他进程可以从中读取。它可以在不同的计算机间进行通信，但是它的速度慢于共享内存。

5. **信号量**：用于进程同步，它通过定义许多信号道来允许多个进程对同一资源进行同步访问。

## 实例演示

例如，可以使用如下代码创建和使用管道实现进程间通信：

```
//创建管道
int fd[2];
pipe(fd);

//创建子进程并写入管道
if(fork()==0){
    char *msg="hello";
    write(fd[1],msg,strlen(msg)+1);
    exit(0);
}

//从管道中读取数据
char buffer[1024];
read(fd[0],buffer,sizeof(buffer));
printf("%s\n",buffer);
```

这段代码中，首先创建了一个管道，然后创建了一个子进程，将一个字符串写入管道。在父进程中，读取从管道返回的字符串并打印。
## 第3节：进程管理

### 后台进程管理和守护进程

在本节中，我们将介绍如何管理后台进程和守护进程。包括如何通过命令行工具将进程放到后台运行，以及如何编写守护进程程序。同时提供实例演示如何使用这些功能。

#### 后台进程管理

1. **放置进程到后台**

在Linux系统中，我们可以使用以下三种方式将正在运行的进程放到后台：

- 使用`&`符号：在执行命令时，在命令尾部添加`&`符号，命令会立即进入后台运行，例如：

  ```
  $ command &
  ```

- 使用`Ctrl+Z`和`bg`命令：使用`Ctrl+Z`将正在运行的命令暂停，然后使用`bg`命令将其放到后台运行，例如：

  ```
  $ command
  Ctrl+Z
  $ bg
  ```

- 使用`nohup`命令：使用`nohup`命令可以让命令在后台运行，并将其输出重定向到指定的文件中，例如：

  ```
  $ nohup command > output.log &
  ```

2. **查看后台进程**

为了查看运行中的后台进程，可以使用`jobs`命令。该命令将显示所有当前在后台运行的任务的列表，例如：

```
$ jobs
[1]+ Running command1 &
[2]- Running command2 &
```

可以使用`fg`命令将后台进程放回前台运行，例如：

```
$ fg %1
```

#### 守护进程

守护进程是指在后台运行的进程，通常是作为服务运行的。守护进程通常在启动时就会将自己的进程ID写入文件中，以方便停止和重新启动。

以下是编写一个简单的守护进程的步骤：

1. 创建一个新的会话，并将当前进程的PID设置为新会话的领头进程。

```c
if (setsid() == -1) {
   perror("Failed to create new session");
   exit(EXIT_FAILURE);
}
```

2. 关闭标准的I/O流，防止在运行时与终端进行交互。

```c
close(STDIN_FILENO);
close(STDOUT_FILENO);
close(STDERR_FILENO);
```

3. 将当前工作目录更改为根目录，以避免在挂载或卸载文件系统时受到影响。

```c
if (chdir("/") == -1) {
    perror("Failed to change working directory");
    exit(EXIT_FAILURE);
}
```

4. 规避守护进程被重复启动的问题，通常使用文件锁或PID文件来实现。

```c
int lockfile = open(LOCK_FILE, O_RDONLY | O_CREAT, 0666);
if (lockfile == -1) {
   perror("Failed to open lock file");
   exit(EXIT_FAILURE);
}

if (flock(lockfile, LOCK_EX | LOCK_NB) == -1) {
   perror("Failed to lock file");
   exit(EXIT_FAILURE);
}

char pid_buf[16];
snprintf(pid_buf, sizeof(pid_buf), "%d\n", getpid());
if (write(lockfile, pid_buf, strlen(pid_buf)) == -1) {
   perror("Failed to write PID to lock file");
   exit(EXIT_FAILURE);
}
```

实现一个守护进程需要参考Linux下的相关编程。
# 第3节:进程管理

## 进程安全和资源限制

在Linux系统下，进程管理不仅需要掌握如何创建、启动和终止进程，还需要了解如何设置进程的资源限制和安全措施，以保证系统的稳定性和安全性。

### 资源限制

#### CPU限制

进程的CPU资源限制可以通过`ulimit`命令进行设置。例如，限制当前shell可以占用CPU时间片的最大时间为10秒：

```
ulimit -t 10
```

#### 内存限制

使用`ulimit`命令可以限制进程可以使用的最大虚拟内存大小。例如，限制当前shell可以使用的最大虚拟内存为1GB：

```
ulimit -v 1000000
```

同时，Linux系统还提供了`cgroups`功能，可用于限制进程对物理内存的使用。使用`systemctl set-memory`命令即可设置某个进程的内存限制，例如：

```
systemctl set-memory nginx.service 1G
```

#### 磁盘限制

使用`quota`命令可以为用户或组设置文件系统磁盘配额。例如，为用户`alice`设置磁盘配额为500MB：

```
edquota -u alice
```

#### 网络限制

使用`iptables`命令可设置防火墙规则，限制进程通过网络的访问权限。

### 进程安全

#### 进程沙盒

进程沙盒是一种隔离机制，可以限制进程对系统资源的访问权限。使用`chroot`命令即可将进程沙盒化，例如：

```
chroot /path/to/chroot /bin/bash
```

#### 防火墙

Linux系统自带了iptables防火墙功能，使用`iptables`命令即可设置防火墙规则，限制进程通过网络的访问权限。例如：

```
iptables -A INPUT -i eth0 -p tcp --dport 22 -j ACCEPT
iptables -A INPUT -i eth0 -j DROP
```

以上规则允许通过eth0网口访问22端口，而其他所有访问都将被禁止。

### 示例演示

假设我们想要通过`ulimit`命令限制当前shell的CPU时间片和虚拟内存大小，并限制`nginx`进程的内存占用。可以按照以下步骤进行设置：

1. 限制当前shell的CPU时间片为10秒：

```
ulimit -t 10
```

2. 限制当前shell的虚拟内存大小为100MB：

```
ulimit -v 100000
```

3. 限制`nginx`进程的内存占用为1GB：

```
systemctl set-memory nginx.service 1G
```

通过以上设置，我们可以有效地限制进程的资源使用，保证系统的稳定性和安全性。同时，通过设置防火墙规则和进程沙盒，还可以进一步提高系统的安全性。
